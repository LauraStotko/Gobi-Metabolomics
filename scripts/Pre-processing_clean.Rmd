---
title: "Gobi: Pre-processing clean"
author: "Marie Hackenberg"
date: "2025-02-03"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Load libraries
```{r}
library(readr)
library(tidyr)
library(dplyr)
library(ggplot2)
library(missForest)
library(doParallel)
library(purrr)
```

# Load data
```{r}
paths <- list(
  metabolon = "../data/raw/humet_data_raw_none_metablon.csv",
  biocrates = "../data/raw/humet_data_raw_none_biocrates.csv",
  inhouse = "../data/raw/humet_data_raw_none_in_house_biochemistry.csv"
)

# Read data into a list using purrr::map
data <- map(paths, read.csv, sep = ",", header = TRUE)
names(data) <- c("data_metabolon", "data_biocrates", "data_inhouse")

# Define platform names for each dataset
platform_names <- c(
  "Metabolon HD4 [nt-ms]",
  "Biocrates p150 [t-ms]",
  "In-house biochemistry [chem.]"
)

# Add platform column
data <- map2(data, platform_names, ~.x %>%
               mutate(platform_name = .y) %>%
               select(platform_name, everything()) # platform name as first column
             )

# Add challenge column depending on time to one version
add_challenge <- function(dataset) {
  dataset %>%
  mutate(challenge = case_when(
    time >= 1 & time <= 9 ~ "fasting",
    time >= 33 & time <= 39 ~ "exercise",
    time >= 40 & time <= 49 ~ "oltt",
    TRUE ~ NA_character_ # assign NA for any time outside ranges
    )) %>%
  dplyr::select(challenge, everything()) # make challenge the first column
}

data <- map(data, add_challenge)

# Filter half the data for relevant timepoints only
relevant_timepoints <- function(dataset) {
  dataset %>%
    filter(!is.na(challenge))  # remove rows where 'challenge' is NA
}

data_filtered_first <- map(data, relevant_timepoints)
data_filtered_last <- data
```

# Identify and remove artefacts
Filtering for outliers defined as data points beyond four standard deviations from the mean and for time points measured after the first 30 minutes of a study challenge, then inspecting manually before removing artefacts is already done in the downloaded dataset.

# Impute missing values using missForest
```{r}
# Prepare data
to_factor <- function(dataset) {
  dataset %>%
  mutate(
    challenge = as.factor(challenge),
    platform_name = as.factor(platform_name),
    time = as.numeric(as.character((time))),
    subject = as.factor(subject),
    )
}

data_filtered_first <- map(data_filtered_first, to_factor)
data_filtered_last <- map(data_filtered_last, to_factor)
```

## Exclude metabolites with more than 30% missing data points
```{r}
keep_sub_30 <- function(dataset) {
  # Count total columns before filtering
  total_cols_before <- ncol(dataset)
  
  # Identify columns with more than 30% missing values
  missing_threshold <- 0.3  # 30% threshold
  cols_to_keep <- colMeans(is.na(dataset)) < missing_threshold | colnames(dataset) == "challenge" # keep challenge column
  
  # Count total columns after filtering
  total_cols_after <- sum(cols_to_keep)
  
  # Filter the dataset to exclude high-missing-value columns
  dataset <- dataset[, cols_to_keep]
  
  # Calculate  number of removed columns
  removed_cols <- total_cols_before - total_cols_after
  
  # Print number of removed columns
  cat("Number of removed columns:", removed_cols, "\n")
  
  return(dataset)
}

data_filtered_first <- map(data_filtered_first, keep_sub_30)
data_filtered_last <- map(data_filtered_last, keep_sub_30)
```

# Performing missForest
```{r}
mF_function <- function(dataset) {
  cat("NA in ",  deparse(substitute(dataset)), " before missForest:", sum(is.na(dataset)), "\n")
  
  if(!sum(is.na(dataset)) == 0) {
    # Set up parallel backend using all available cores minus one
    cl <- makeCluster(detectCores() - 1, type = "FORK")  # Use one less core to avoid overloading; Mac-specific "FORK" cluster type
    registerDoParallel(cl)
    
    # Perform missForest imputation
    set.seed(42)  # Ensures reproducibility
    imputed_dataset <- missForest(dataset, ntree = 450, parallelize = "variables", verbose = "TRUE") # default ntree = 100; verbose=True to get progress messages              # ACHTUNG: DAUERT LANGE!!
    
    stopCluster(cl)  # Stop  cluster after imputation
    
    # Extract imputed dataset
    imputed_dataset <- imputed_dataset$ximp
  } else {
    imputed_dataset <- dataset
  }
  cat("NA in ",  deparse(substitute(dataset)), " after missForest:", sum(is.na(imputed_dataset)), "\n")
  
  return(imputed_dataset)
}

#data_filtered_first[[1]] <- mF_function(data_filtered_first[[1]]) # data_metabolon_filtered_first
#data_filtered_first<- <- mF_function(data_filtered_first[2]) # data_biocrates_filtered_first # Marie
#data_filtered_first[[3]] <- mF_function(data_filtered_first[3]) # data_inhouse_filtered_first # Anna

#data_filtered_last[[1]] <- mF_function(data_filtered_last[[1]]) # data_metabolon_filtered_last
#filtered_last[[2]]- mF_function(data_filtered_last[2]) # data_biocrates_filtered_last # Laura
#filtered_last[[3]] <- mF_function(data_filtered_last[3]) # data_inhouse_filtered_last # Diana

# # alternative to individually
#data_filtered_first <- map(data_filtered_first, mF_function)
#data_filtered_last <- map(data_filtered_last, mF_function)
```

# Log2 Transform
```{r}
log2_transformed <- function(dataset) {
  dataset %>%
    mutate(time = as.factor(time)) %>% # refactor time column as factor to exclude from log2_transformation
    mutate(across(where(is.numeric), log2))
}

#data_filtered_first[[1]] <- log2_transformed(data_filtered_first[[1]]) # imputed_metabolon_filtered_first
#data_filtered_first[[2]] <- log2_transformed(data_filtered_first[2]) # imputed_biiocrates_filtered_first # Marie
#data_filtered_first[[3]] <- log2_transformed(data_filtered_first[3]) # imputed_inhouse_filtered_first # Anna

#data_filtered_last[[1]] <- log2_transformed(data_filtered_last[[1]]) # imputed_metabolon_filtered_last
#data_filtered_last[[2]] <- log2_transformed(data_filtered_last[2]) # imputed_biocrates_filtered_last # Laura
#data_filtered_last[[3]] <- log2_transformed(data_filtered_last[3]) # imputed_inhouse_filtered_last # Diana

# # alternative to individually
# data_filtered_first <- map(data_filtered_first, log2_transformed)
# data_filtered_last <- map(data_filtered_last, log2_transformed)
```


# Filter unfiltered data for relevant timepoints
```{r}
relevant_timepoints <- function(dataset) {
  dataset %>%
    filter(!is.na(challenge))  # remove rows where 'challenge' is NA
}

#data_filtered_last[[1]] <- relevant_timepoints(data_filtered_last[[1]]) # log2_imputed_metabolon_filtered_last
#data_filtered_last[[2]] <- relevant_timepoints(data_filtered_last[2]) # log2_imputed_biocrates_filtered_last # Laura
#data_filtered_last[[3]] <- relevant_timepoints(data_filtered_last[3]) # log2_imputed_inhouse_filtered_last # Diana

# # alternative to individually
# data_filtered_last <- map(data_filtered_last, log2_transformed)
# data_filtered_last <- map(data_filtered_last, log2_transformed)
```

```{r}
# Save to a CSV file
#write.csv(data_filtered_first[[1]], "../figures/preproc_metabolon_filtered_first.csv", row.names = FALSE)
#write.csv(data_filtered_first[[2]], "../figures/preproc_biocrates_filtered_first.csv", row.names = FALSE) # Marie
#write.csv(data_filtered_first[[3]], "../figures/lpreproc_inhouse_filtered_first.csv", row.names = FALSE) # Anna

#write.csv(data_filtered_last[[1]], "../figures/preproc_metabolon_filtered_last.csv", row.names = FALSE)
#write.csv(data_filtered_last[[2]], "../figures/preproc_biocrates_filtered_last.csv", row.names = FALSE) # Laura
#write.csv(data_filtered_last[[3]], "../figures/preproc_inhouse_filtered_last.csv", row.names = FALSE) # Diana


# # alternative to individually
# output_paths <- c(
#   "../figures/preproc_metabolon_filtered_first.csv",
#   "../figures/preproc_biocrates_filtered_first.csv",
#   "../figures/preproc_inhouse_filtered_first.csv",
#   "../figures/preproc_metabolon_filtered_last.csv",
#   "../figures/preproc_biocrates_filtered_last.csv",
#   "../figures/preproc_inhouse_filtered_last.csv"
# )
# preproc_datasets <- c(data_filtered_first, data_filtered_last)
# map2(preproc_datasets, output_paths, ~ write.csv(.x, .y, row.names = FALSE)) # row.names=false to only use existing rownames from here
```
# End