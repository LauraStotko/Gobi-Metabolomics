---
title: "Gobi: Pre-processing clean"
author: "Marie Hackenberg"
date: "2025-02-03"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Show overall start time
start_time_overall <- Sys.time()
cat("Starting re-processing at ", format(start_time_overall, "%H:%M:%S"), "\n")
```

# Load libraries
```{r}
library(readr)
library(tidyr)
library(dplyr)
library(ggplot2)
library(missForest)
library(doParallel)
library(purrr)
```

# Load data
```{r}
paths <- list(
  metabolon = "../data/raw/humet_data_raw_none_metablon.csv",
  biocrates = "../data/raw/humet_data_raw_none_biocrates.csv",
  inhouse = "../data/raw/humet_data_raw_none_in_house_biochemistry.csv",
  z_metabolon = "../data/processed/humet_data_zscore_none_subjects15_tp57_m.csv",
  z_biocrates = "../data/processed/humet_data_zscore_none_subjects15_tp57_b.csv",
  z_inhouse = "../data/processed/humet_data_zscore_none_subjects15_tp57_i.csv"
)

# Read data into a list using purrr::map
data <- map(paths, read.csv, sep = ",", header = TRUE)
names(data) <- c("data_metabolon", "data_biocrates", "data_inhouse", "z_metabolon", "z_biocrates", "z_inhouse")

# Define platform names for each dataset
platform_names <- c(
  "Metabolon HD4 [nt-ms]",
  "Biocrates p150 [t-ms]",
  "In-house biochemistry [chem.]",
  "Metabolon HD4 [nt-ms]",
  "Biocrates p150 [t-ms]",
  "In-house biochemistry [chem.]"
)

# Add platform column
data <- map2(data, platform_names, ~.x %>%
               mutate(platform_name = .y) %>%
               select(platform_name, everything()) # platform name as first column
             )

# Add challenge column depending on time to one version
add_challenge <- function(dataset) {
  dataset %>%
  mutate(challenge = case_when(
    time >= 1 & time <= 9 ~ "fasting",
    time >= 33 & time <= 39 ~ "exercise",
    time >= 40 & time <= 49 ~ "oltt",
    TRUE ~ NA_character_ # assign NA for any time outside ranges
    )) %>%
  dplyr::select(challenge, everything()) # make challenge the first column
}

data <- map(data, add_challenge)

# Filter half the data for relevant timepoints only
relevant_timepoints <- function(dataset) {
  dataset %>%
    filter(!is.na(challenge))  # remove rows where 'challenge' is NA
}

data <- c(map(data[1:3], relevant_timepoints), data[1:3], map(data[4:6], relevant_timepoints), data[4:6])
```

# Identify and remove artefacts
Filtering for outliers defined as data points beyond four standard deviations from the mean and for time points measured after the first 30 minutes of a study challenge, then inspecting manually before removing artefacts is already done in the downloaded dataset.

# Impute missing values using missForest
```{r}
# Prepare data
to_factor <- function(dataset) {
  dataset %>%
  mutate(
    challenge = as.factor(challenge),
    platform_name = as.factor(platform_name),
    time = as.numeric(as.character((time))),
    subject = as.factor(subject),
    )
}

data <- map(data, to_factor)
```

## Exclude metabolites with more than 30% missing data points
```{r}
keep_sub_30 <- function(dataset) {
  # Count total columns before filtering
  total_cols_before <- ncol(dataset)
  
  # Identify columns with more than 30% missing values
  missing_threshold <- 0.3  # 30% threshold
  cols_to_keep <- colMeans(is.na(dataset)) < missing_threshold | colnames(dataset) == "challenge" # keep challenge column
  
  # Count total columns after filtering
  total_cols_after <- sum(cols_to_keep)
  
  # Filter the dataset to exclude high-missing-value columns
  dataset <- dataset[, cols_to_keep]
  
  # Calculate  number of removed columns
  removed_cols <- total_cols_before - total_cols_after
  
  # Print number of removed columns
  cat("Number of removed columns:", removed_cols, "\n")
  
  return(dataset)
}

data <- map(data, keep_sub_30)
```

# Performing missForest
```{r}
# mF_function <- function(dataset) {
#   cat("NA in ",  deparse(substitute(dataset)), " before missForest:", sum(is.na(dataset)), "\n")
#   
#   if(!sum(is.na(dataset)) == 0) {
#     # Set up parallel backend using all available cores minus one
#     cl <- makeCluster(detectCores() - 1, type = "FORK")  # Use one less core to avoid overloading; Mac-specific "FORK" cluster type
#     registerDoParallel(cl)
#     
#     # Perform missForest imputation
#     set.seed(42)  # Ensures reproducibility
#     imputed_dataset <- missForest(dataset, ntree = 1, parallelize = "variables", verbose = "FALSE") # default ntree = 100; verbose=True to get progress messages              # ACHTUNG: DAUERT LANGE!!
#     
#     stopCluster(cl)  # Stop  cluster after imputation
#     
#     # Extract imputed dataset
#     imputed_dataset <- imputed_dataset$ximp
#   } else {
#     imputed_dataset <- dataset
#   }
#   cat("NA in ",  deparse(substitute(dataset)), " after missForest:", sum(is.na(imputed_dataset)), "\n\n\n")
#   
#   return(imputed_dataset)
# }
# 
# data <- map(data, mF_function)



mF_function <- function(dataset, name) {
  start_time <- Sys.time()
  cat(format(start_time, "%H:%M:%S"), "- NA in", name, "before:", sum(is.na(dataset)), "\n")
  
  if (sum(is.na(dataset)) > 0) {
    cl <- makeCluster(detectCores() - 1, type = "FORK"); registerDoParallel(cl)
    dataset <- missForest(dataset, ntree = 100, parallelize = "variables", verbose = FALSE)$ximp
    stopCluster(cl)
  }
  
  end_time <- Sys.time()
  cat(format(end_time, "%H:%M:%S"), "- NA in", name, "- after:", sum(is.na(dataset)), " (Time elapsed:", round(difftime(end_time, start_time, units = "secs"), 2), "sec)\n\n")
  
  return(dataset)
}

# # missForest for fewer #del
# fewer <- data[[7]]
# empty_cols <- colSums(is.na(fewer)) == nrow(fewer)  # identify columns with all NA values
# print(names(fewer)[empty_cols])
# fewer <- imap(fewer, mF_function)
# data <- fewer



# Show start time
start_time_mF <- Sys.time()
cat("Starting missForest at ", format(start_time_mF, "%H:%M:%S"), "\n")

# Impute
data <- imap(data, mF_function)

# Show finish time and elasped time
end_time_mF <- Sys.time()
cat("Finished missForest at ", format(end_time_mF, "%H:%M:%S"), " (Time elapsed:", round(difftime(end_time_mF, start_time_mF, units = "mins"), 2), "min)\n")
```

# Log2 transform only the non-zscore data
```{r}
# log2_transformed <- function(dataset) {
#   dataset %>%
#     mutate(time = as.factor(time)) %>% # refactor time column as factor to exclude from log2_transformation
#     mutate(across(where(is.numeric), ~ ifelse(. > 0, log2(.), NA))) # robust against zero/negative values
# }

log2_transformed <- function(dataset) {
  dataset %>%
    mutate(time = as.factor(time)) %>% # refactor time column as factor to exclude from log2_transformation
    mutate(across(where(is.numeric), log2))
}

data <- c(map(data[1:6], log2_transformed), data[7:12])

#data_filtered_first[[1]] <- log2_transformed(data_filtered_first[[1]]) # imputed_metabolon_filtered_first
#data_filtered_first[[2]] <- log2_transformed(data_filtered_first[2]) # imputed_biiocrates_filtered_first # Marie
#data_filtered_first[[3]] <- log2_transformed(data_filtered_first[3]) # imputed_inhouse_filtered_first # Anna

#data_filtered_last[[1]] <- log2_transformed(data_filtered_last[[1]]) # imputed_metabolon_filtered_last
#data_filtered_last[[2]] <- log2_transformed(data_filtered_last[2]) # imputed_biocrates_filtered_last # Laura
#data_filtered_last[[3]] <- log2_transformed(data_filtered_last[3]) # imputed_inhouse_filtered_last # Diana

# # alternative to individually
# data_filtered_first <- map(data_filtered_first, log2_transformed)
# data_filtered_last <- map(data_filtered_last, log2_transformed)
```


# Filter unfiltered data for relevant timepoints #todo: not working within list
```{r}
relevant_timepoints <- function(dataset) {
  dataset %>%
    filter(!is.na(challenge))  # remove rows where 'challenge' is NA
}

data <- c(map(data[1:3], relevant_timepoints), data[4:6], map(data[7:9], relevant_timepoints), data[10:12])

#data_filtered_last[[1]] <- relevant_timepoints(data_filtered_last[[1]]) # log2_imputed_metabolon_filtered_last
#data_filtered_last[[2]] <- relevant_timepoints(data_filtered_last[2]) # log2_imputed_biocrates_filtered_last # Laura
#data_filtered_last[[3]] <- relevant_timepoints(data_filtered_last[3]) # log2_imputed_inhouse_filtered_last # Diana

# # alternative to individually
# data_filtered_last <- map(data_filtered_last, log2_transformed)
# data_filtered_last <- map(data_filtered_last, log2_transformed)
```

```{r}
# Save to a CSV file
#write.csv(data_filtered_first[[1]], "../figures/preproc_metabolon_filtered_first.csv", row.names = FALSE)
#write.csv(data_filtered_first[[2]], "../figures/preproc_biocrates_filtered_first.csv", row.names = FALSE) # Marie
#write.csv(data_filtered_first[[3]], "../figures/lpreproc_inhouse_filtered_first.csv", row.names = FALSE) # Anna

#write.csv(data_filtered_last[[1]], "../figures/preproc_metabolon_filtered_last.csv", row.names = FALSE)
#write.csv(data_filtered_last[[2]], "../figures/preproc_biocrates_filtered_last.csv", row.names = FALSE) # Laura
#write.csv(data_filtered_last[[3]], "../figures/preproc_inhouse_filtered_last.csv", row.names = FALSE) # Diana


# alternative to individually
output_paths <- c(
  "../figures/preproc_metabolon_filtered_first.csv",
  "../figures/preproc_biocrates_filtered_first.csv",
  "../figures/preproc_inhouse_filtered_first.csv",
  "../figures/preproc_metabolon_filtered_last.csv",
  "../figures/preproc_biocrates_filtered_last.csv",
  "../figures/preproc_inhouse_filtered_last.csv",

  "../figures/preproc_z_metabolon_filtered_first.csv",
  "../figures/preproc_z_biocrates_filtered_first.csv",
  "../figures/preproc_z_inhouse_filtered_first.csv",
  "../figures/preproc_z_metabolon_filtered_last.csv",
  "../figures/preproc_z_biocrates_filtered_last.csv",
  "../figures/preproc_z_inhouse_filtered_last.csv"
)
# Assuming 'data' is a list of lists
#flattened_data <- unlist(data, recursive = FALSE)
#map2(flattened_data, output_paths, ~ write.csv(.x, .y, row.names = FALSE))

for (i in 1:length(data)) {
  write.csv(data[[i]], output_paths[i], row.names = FALSE)
}

  
#map2(data, output_paths, ~ write.csv(.x, .y, row.names = FALSE)) # row.names=false to only use existing rownames from here
```

```{r}
# Show overall finish time and elasped time
end_time_overall <- Sys.time()
cat("Finished pre-processing at ", format(end_time_overall, "%H:%M:%S"), " (Time elapsed:", round(difftime(end_time_overall, start_time_overall, units = "mins"), 2), "min)\n")
```
# End