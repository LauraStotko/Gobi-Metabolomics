---
title: "Cluster Visualization"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Load the data
data <- read.csv("/Users/laura.stotko/Documents/Gobi-Metabolomics/Clustering/mfuzz_clusters_by_challenge_with_time_respone.csv")

# Clean column names
colnames(data) <- make.names(colnames(data), unique = TRUE)

# Sicherstellen, dass die response-Spalte numerisch ist
data$Response <- as.numeric(data$Response)

# Definiere alle möglichen Timepoint-Werte
all_Timepoints <- seq(0, 240, 60)

# Individuelle Linien-Daten vorbereiten (alle Response-Werte in Long-Format bringen)
individual_data <- data %>%
  complete(Assigned_Cluster, Challenge, Timepoint = all_Timepoints) %>% # Fehlende Zeitpunkte auffüllen
  group_by(Assigned_Cluster, Challenge) %>%
  mutate(Response = zoo::na.approx(Response, x = Timepoint, na.rm = FALSE)) %>%
  ungroup()

# Mittelwert-Daten vorbereiten
mean_profiles <- data %>%
  group_by(Assigned_Cluster, Challenge, Timepoint) %>%
  summarise(Mean_Response = mean(Response, na.rm = TRUE), .groups = "drop") %>%
  complete(Assigned_Cluster, Challenge, Timepoint = all_Timepoints) %>% # Fehlende Zeitpunkte auffüllen
  group_by(Assigned_Cluster, Challenge) %>%
  mutate(Mean_Response = zoo::na.approx(Mean_Response, x = Timepoint, na.rm = FALSE)) %>%
  ungroup()

# Plots erstellen für jedes Cluster
for (cluster in unique(mean_profiles$Assigned_Cluster)) {
  # Daten für den spezifischen Cluster filtern
  cluster_individual_data <- individual_data %>%
    filter(Assigned_Cluster == cluster)
  
  cluster_mean_data <- mean_profiles %>%
    filter(Assigned_Cluster == cluster)
  
  # Plot erstellen
  p <- ggplot() +
    # Individuelle Linien in hellgrau (Hintergrund)
    geom_line(data = cluster_individual_data, 
              aes(x = Timepoint, y = Response, group = interaction(Assigned_Cluster, Challenge)), 
              color = "lightgrey", size = 0.5, alpha = 0.7) +
    # Mittelwertlinie in grün (Vordergrund)
    geom_line(data = cluster_mean_data, 
              aes(x = Timepoint, y = Mean_Response, color = Challenge), 
              size = 1.2) +
    facet_wrap(~ Challenge, ncol = 3) +                         # Drei Challenges nebeneinander
    scale_y_continuous() +                     # Einheitliche y-Achse
    scale_x_continuous(limits = c(0, 240), breaks = seq(0, 240, 60)) +              # Einheitliche x-Achse
    labs(title = paste("Cluster", cluster, "- Challenges"),
         x = "Challenge Time [min]", 
         y = "Metabolite Response") +
    theme_minimal() +
    theme(
      panel.grid.major = element_blank(),       # Entfernt Hauptgitterlinien
      panel.grid.minor = element_blank(),       # Entfernt Nebengitterlinien
      panel.background = element_blank(),       # Entfernt Panel-Hintergrund
      axis.line = element_line(color = "black"),  # Fügt Achsenlinien hinzu
      axis.ticks = element_line(color = "black"), # Fügt Tick-Linien hinzu
      strip.background = element_rect(fill = "white", color = "black"), # Cluster-Titel hervorheben
      strip.text = element_text(size = 10),    # Facetten-Titel
      legend.position = "top",                 # Legende oben anzeigen
      panel.spacing = unit(1, "lines")         # Abstand zwischen den Facetten
    )
  
  # Plot anzeigen
  print(p)
}
```




